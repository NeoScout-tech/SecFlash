import sqlite3
import logging
import json
import os
import zipfile
import re
from typing import Dict, List, Tuple, Optional
from report_generator import ReportGenerator
import nvdlib
import time
import requests

# Настраиваем логирование
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("vulnerability_analyzer.log"),
        logging.StreamHandler()
    ]
)

class VulnerabilityAnalyzer:
    def __init__(self):
        self.db_path = "nvd_data.db"
        self.report_generator = ReportGenerator()
        self.api_key = os.getenv("NVD_API_KEY", "4b2f74a1-296c-4146-a937-6994ca3b17c9")
        if not self.api_key:
            logging.warning("API-ключ NVD не установлен.")
        else:
            logging.info(f"Используется API-ключ: {self.api_key[:8]}...")

        # Словарь CPE без версий
        self.CPE_MAPPING = {
            "apache httpd": {"vendor": "apache", "part": "a", "product": "http_server"},
            "nginx": {"vendor": "nginx", "part": "a", "product": "nginx"},
            "mysql": {"vendor": "oracle", "part": "a", "product": "mysql"},
            "windows server": {"vendor": "microsoft", "part": "o", "product": "windows_server"},
            "wordpress": {"vendor": "wordpress", "part": "a", "product": "wordpress"},
            "tomcat": {"vendor": "apache", "part": "a", "product": "tomcat"},
            "openssl": {"vendor": "openssl", "part": "a", "product": "openssl"},
            "php": {"vendor": "php", "part": "a", "product": "php"},
            "java": {"vendor": "oracle", "part": "a", "product": "jdk"},
            "openssh": {"vendor": "openbsd", "part": "a", "product": "openssh"},
            "smb": {"vendor": "samba", "part": "a", "product": "samba"},
            "ubuntu": {"vendor": "canonical", "part": "o", "product": "ubuntu_linux"}
        }

        self._initialize_database()

    def _initialize_database(self):
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS vulnerabilities (
                    cve_id TEXT,
                    cpe TEXT,
                    description TEXT,
                    severity TEXT,
                    cvss REAL,
                    recommendations TEXT,
                    PRIMARY KEY (cve_id, cpe)
                )
            """)
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_cpe ON vulnerabilities(cpe)")
            conn.commit()
            logging.info("База данных инициализирована успешно")
        except sqlite3.Error as e:
            logging.error(f"Ошибка инициализации базы данных: {str(e)}")
            raise
        finally:
            conn.close()

    def _connect_db(self) -> sqlite3.Connection:
        try:
            conn = sqlite3.connect(self.db_path)
            logging.info("Подключение к базе данных успешно")
            return conn
        except sqlite3.Error as e:
            logging.error(f"Ошибка подключения к базе данных: {str(e)}")
            raise

    def _get_cpe_for_service(self, service: str) -> Tuple[str, str, str, Optional[str]]:
        """Извлечение vendor, product, version из сервиса"""
        service_lower = service.lower()
        version = None

        # Специальная обработка для Windows Server
        if "windows server" in service_lower:
            version_match = re.search(r'windows server\s+(\d{4}|\d+\.\d+\.\d+)', service_lower)
            if version_match:
                version = version_match.group(1)
            service_name = "windows server"
        else:
            # Для других сервисов извлекаем версию
            version_match = re.search(r'(\d+\.\d+\.\d+[\w\-]*)', service_lower)
            if version_match:
                version = version_match.group(1)
                service_name = service_lower.replace(version, '').strip()
            else:
                service_name = service_lower

        for key, cpe_info in self.CPE_MAPPING.items():
            if key in service_name:
                return (
                    cpe_info["part"],
                    cpe_info["vendor"],
                    cpe_info["product"],
                    version
                )
        logging.warning(f"Не найдено CPE для сервиса: {service}")
        return "a", "unknown", "unknown", None

    def _validate_cpe(self, part: str, vendor: str, product: str, version: Optional[str] = None) -> Optional[str]:
        """Поиск CPE с учетом версии"""
        # Специальная обработка для WordPress
        if product == "wordpress":
            if version:
                return f"cpe:2.3:a:wordpress:wordpress:{version}:*:*:*:*:*:*:*"
            return "cpe:2.3:a:wordpress:wordpress:*:*:*:*:*:*:*:*"

        # Нормализация версии
        normalized_version = version
        if product == "jdk" and version and version.startswith("1.8.0_"):
            normalized_version = f"8u{version.split('_')[1]}"
        if product == "ubuntu_linux" and version:
            normalized_version = version.split(".")[0] + "." + version.split(".")[1]
        if product == "windows_server" and version:
            normalized_version = version if version.isdigit() else version.replace(".", "")

        keywords = [
            f"{vendor} {product} {normalized_version}" if normalized_version else f"{vendor} {product}",
            f"{vendor} {product}",
            f"{product} {normalized_version}" if normalized_version else product,
            vendor,
            f"{vendor}:{product}",
            f"{vendor} {product.replace('_', ' ')}",
            "apache http_server" if product == "http_server" else "",
            f"microsoft windows_server_{normalized_version}" if product == "windows_server" and normalized_version else "microsoft windows_server",
            f"samba {normalized_version}" if product == "samba" and normalized_version else "samba",
            f"oracle jdk {normalized_version}" if product == "jdk" and normalized_version else "oracle jdk",
            f"apache http_server {normalized_version}" if product == "http_server" and normalized_version else "apache http_server",
            f"{product.replace('_', ' ')} {normalized_version}" if normalized_version else product.replace('_', ' '),
            f"{vendor} {product.replace('_', '-')}",
        ]

        for keyword in keywords:
            if not keyword:
                continue
            try:
                logging.info(f"Поиск CPE с ключевым словом: {keyword}")
                cpe_results = nvdlib.searchCPE(keywordSearch=keyword, key=self.api_key, delay=0.6)
                for cpe in cpe_results:
                    cpe_name = cpe.cpeName.lower()
                    if vendor.lower() in cpe_name and product.lower().replace('_', '') in cpe_name.replace('_', '').replace('-', ''):
                        if product == "samba" and any(x in cpe_name for x in ["rsync", "node.js", "samba-client", "samba-tng"]):
                            continue
                        if product == "wordpress" and "plugin" in cpe_name:
                            continue
                        if product == "http_server" and "http_server" not in cpe_name:
                            continue
                        version_parts = normalized_version.split('.') if normalized_version else []
                        short_version = '.'.join(version_parts[:2]) if len(version_parts) >= 2 else normalized_version
                        if normalized_version and (short_version.lower() in cpe_name or normalized_version.lower() in cpe_name):
                            logging.info(f"Найден подходящий CPE: {cpe.cpeName}")
                            return cpe.cpeName
                        elif not normalized_version:
                            logging.info(f"Найден подходящий CPE: {cpe.cpeName}")
                            return cpe.cpeName
                logging.warning(f"Нет результатов для ключевого слова: {keyword}")
            except requests.exceptions.HTTPError as e:
                if e.response.status_code == 404:
                    logging.warning(f"Ошибка 404 для ключевого слова: {keyword}")
                    continue
                logging.error(f"Ошибка поиска CPE для {keyword}: {str(e)}")
                continue
            except Exception as e:
                logging.error(f"Ошибка поиска CPE для {keyword}: {str(e)}")
                continue

        logging.warning(f"Не найдено CPE для {vendor}:{product} (версия: {version})")
        return None

    def _query_cached_vulnerabilities(self, part: str, vendor: str, product: str, version: Optional[str] = None) -> List[Dict]:
        conn = self._connect_db()
        cursor = conn.cursor()
        try:
            query = """
                SELECT cve_id, cpe, description, severity, cvss, recommendations
                FROM vulnerabilities
                WHERE cpe LIKE ?
            """
            cpe_pattern = f"cpe:2.3:{part}:{vendor}:{product}:{version}%"
            cursor.execute(query, (cpe_pattern,))
            rows = cursor.fetchall()
            vulnerabilities = [
                {
                    "cve_id": row[0],
                    "cpe": row[1],
                    "description": row[2],
                    "severity": row[3],
                    "cvss": row[4],
                    "recommendations": json.loads(row[5]) if row[5] else []
                }
                for row in rows
            ]
            logging.info(f"Найдено кэшированных уязвимостей для {vendor}:{product} (версия: {version}): {len(vulnerabilities)}")
            return vulnerabilities
        except sqlite3.Error as e:
            logging.error(f"Ошибка запроса к базе данных: {str(e)}")
            return []
        finally:
            conn.close()

    def _fetch_nvd_vulnerabilities(self, part: str, vendor: str, product: str, version: Optional[str] = None) -> List[Dict]:
        cpe_string = self._validate_cpe(part, vendor, product, version)
        if not cpe_string:
            logging.warning(f"Пропуск запроса к NVD для {vendor}:{product} из-за отсутствия валидного CPE")
            return []

        # Пропускаем WordPress из-за ненадежных данных в NVD
        if product == "wordpress":
            logging.info(f"Пропуск запроса к NVD для WordPress, так как уязвимости не надежны в NVD")
            return []

        vulnerabilities = []
        retries = 3
        for attempt in range(retries):
            try:
                cve_results = nvdlib.searchCVE(cpeName=cpe_string, limit=1000, key=self.api_key, delay=0.6)
                for cve in cve_results:
                    description = cve.descriptions[0].value if cve.descriptions else "Нет описания"
                    cvss = "N/A"
                    severity = "N/A"

                    # Извлечение CVSS метрик
                    if hasattr(cve, 'metrics'):
                        # CVSS v4.0
                        if hasattr(cve.metrics, 'cvssMetricV40') and cve.metrics.cvssMetricV40:
                            cvss_data = cve.metrics.cvssMetricV40[0].cvssData
                            cvss = cvss_data.baseScore if hasattr(cvss_data, 'baseScore') else "N/A"
                            severity = cve.metrics.cvssMetricV40[0].baseSeverity if hasattr(cve.metrics.cvssMetricV40[0], 'baseSeverity') else "N/A"
                            logging.debug(f"CVE {cve.id}: CVSS v4.0 - Score: {cvss}, Severity: {severity}")
                        # CVSS v3.1
                        elif hasattr(cve.metrics, 'cvssMetricV31') and cve.metrics.cvssMetricV31:
                            cvss_data = cve.metrics.cvssMetricV31[0].cvssData
                            cvss = cvss_data.baseScore if hasattr(cvss_data, 'baseScore') else "N/A"
                            severity = cve.metrics.cvssMetricV31[0].baseSeverity if hasattr(cve.metrics.cvssMetricV31[0], 'baseSeverity') else "N/A"
                            logging.debug(f"CVE {cve.id}: CVSS v3.1 - Score: {cvss}, Severity: {severity}")
                        # CVSS v3.0
                        elif hasattr(cve.metrics, 'cvssMetricV30') and cve.metrics.cvssMetricV30:
                            cvss_data = cve.metrics.cvssMetricV30[0].cvssData
                            cvss = cvss_data.baseScore if hasattr(cvss_data, 'baseScore') else "N/A"
                            severity = "N/A"  # CVSS v3.0 не предоставляет baseSeverity
                            logging.debug(f"CVE {cve.id}: CVSS v3.0 - Score: {cvss}, Severity: {severity}")
                        # CVSS v2.0 (для старых CVE)
                        elif hasattr(cve.metrics, 'cvssMetricV2') and cve.metrics.cvssMetricV2:
                            cvss_data = cve.metrics.cvssMetricV2[0]
                            cvss = cvss_data.baseScore if hasattr(cvss_data, 'baseScore') else "N/A"
                            severity = "N/A"  # CVSS v2.0 не предоставляет baseSeverity
                            logging.debug(f"CVE {cve.id}: CVSS v2.0 - Score: {cvss}, Severity: {severity}")
                        else:
                            logging.warning(f"Нет поддерживаемых CVSS метрик для CVE {cve.id}: {cve.metrics}")
                            cvss = 10.0  # Наихудший сценарий
                            severity = "Critical"
                    else:
                        logging.warning(f"Нет метрик для CVE {cve.id}")
                        cvss = 10.0  # Наихудший сценарий
                        severity = "Critical"

                    # Фильтрация по версии (если версия указана)
                    if version and cpe_string:
                        cpe_version = cpe_string.split(':')[5]
                        if cpe_version != '-' and cpe_version != version and version not in cpe_version:
                            logging.debug(f"Пропуск CVE {cve.id} для {vendor}:{product}:{version} - несоответствие версии CPE: {cpe_version}")
                            continue

                    recommendations = ["Обновите до последней версии", "Примените патчи безопасности"]
                    vuln = {
                        "cve_id": cve.id,
                        "cpe": cpe_string,
                        "description": description,
                        "severity": severity,
                        "cvss": cvss,
                        "recommendations": recommendations
                    }
                    vulnerabilities.append(vuln)

                if vulnerabilities:
                    conn = self._connect_db()
                    cursor = conn.cursor()
                    try:
                        for vuln in vulnerabilities:
                            cursor.execute("""
                                INSERT OR REPLACE INTO vulnerabilities (cve_id, cpe, description, severity, cvss, recommendations)
                                VALUES (?, ?, ?, ?, ?, ?)
                            """, (
                                vuln["cve_id"],
                                vuln["cpe"],
                                vuln["description"],
                                vuln["severity"],
                                vuln["cvss"],
                                json.dumps(vuln["recommendations"])
                            ))
                        conn.commit()
                        logging.info(f"Кэшировано уязвимостей для {vendor}:{product}: {len(vulnerabilities)}")
                    except sqlite3.Error as e:
                        logging.error(f"Ошибка кэширования уязвимостей: {str(e)}")
                    finally:
                        conn.close()
                return vulnerabilities
            except requests.exceptions.HTTPError as e:
                if e.response.status_code == 404:
                    logging.warning(f"Нет уязвимостей для CPE {cpe_string}")
                    return []
                if e.response.status_code in [429, 403]:
                    logging.warning(f"Превышен лимит, повтор через {2 ** attempt} секунд...")
                    time.sleep(2 ** attempt)
                    continue
                logging.error(f"Ошибка запроса к NVD для {vendor}:{product}: {str(e)}")
                return []
            except Exception as e:
                logging.error(f"Ошибка запроса к NVD для {vendor}:{product}: {str(e)}")
                return []
        logging.error(f"Не удалось получить данные после {retries} попыток для {vendor}:{product}")
        return []

    def analyze_network(self, network_data: Dict) -> List[Dict]:
        findings = []
        seen_cves = set()  # Для предотвращения дублирования CVE
        for host in network_data.get("hosts", []):
            if host.get("status") != "active":
                continue
            ip = host.get("ip", "unknown")
            ports = host.get("ports", [])
            services = host.get("services", [])

            for service in services:
                part, vendor, product, version = self._get_cpe_for_service(service)
                if vendor == "unknown":
                    continue

                vulnerabilities = self._query_cached_vulnerabilities(part, vendor, product, version)
                if not vulnerabilities:
                    logging.info(f"Кэш пуст, запрашиваем NVD для {vendor}:{product} (версия: {version})")
                    vulnerabilities = self._fetch_nvd_vulnerabilities(part, vendor, product, version)

                for vuln in vulnerabilities:
                    cve_key = f"{vuln['cve_id']}:{service}"  # Уникальный ключ для CVE и сервиса
                    if cve_key in seen_cves:
                        continue
                    seen_cves.add(cve_key)
                    findings.append({
                        "ip": ip,
                        "ports": ports,
                        "service": service,
                        "cve_id": vuln["cve_id"],
                        "description": vuln["description"],
                        "severity": vuln["severity"],
                        "cvss": vuln["cvss"],
                        "recommendations": vuln["recommendations"]
                    })

        logging.info(f"Обнаружено уязвимостей: {len(findings)}")
        return findings

    def generate_all_reports(self, network_data: Dict) -> Dict:
        findings = self.analyze_network(network_data)
        reports = []
        reports.append(self.report_generator.generate_no_gradient_black(network_data, findings))
        reports.append(self.report_generator.generate_no_gradient_black_booklet(network_data, findings))
        reports.append(self.report_generator.generate_gradient_white_black(network_data, findings))
        reports.append(self.report_generator.generate_gradient_white_black_booklet(network_data, findings))
        zip_filename = f"{network_data.get('location', 'Report').replace(' ', '_')}.zip"
        with zipfile.ZipFile(zip_filename, 'w', zipfile.ZIP_DEFLATED) as zipf:
            for report_file in reports:
                if os.path.exists(report_file):
                    zipf.write(report_file, os.path.basename(report_file))
                    logging.info(f"Добавлен файл в архив: {report_file}")
        logging.info(f"ZIP-архив создан: {zip_filename}")
        return {"reports": reports, "archive": zip_filename}